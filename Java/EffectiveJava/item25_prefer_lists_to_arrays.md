### Item25 : Prefer lists to arrays

----------

Arrays differ from generic types in two important ways. First, arrays are *covariant*. It means that if `Sub` is a subtype of `Super`, then the array type `Sub[]` is a subtype of `Super[]`. Generics, by contrast, are *invariant*: for any two distinct types `Type1` and `Type2`, `List<Type1>` is neither a subtype nor a supertype of `List<Type2>`. You might think this means that generics are deficient, but arguably it is arrays that are deficient:

This code fragment is legal:

```java
// Fails at runtime!
Object[] objectArray = new Long[1];
objectArray[0] = "I don't fit in"; // Throws ArrayStoreException
```

but this one is not:

```java
// Won't compile!
List<Object> list = new ArrayList<Long>(); // Incompatible types
list.add("I don't fit in"):
```

Either way you can't put a `String` into a `Long` container, but with an array you find out that you've made a mistake at runtime; with a list, you find out at compile time. Of course you would rather find out at compile time.

The second major difference between arrays and generics is that arrays are *reified*. This means that arrays know and enforce their element types at runtime. As noted above, if you try to store a `String` into an array of `Long`, you'll get an `ArrayStoreException`. Generics, by contrast, are implemented by *erasure*. This means that they enforce their type constraints only at compile time and discard/erase their element type information at runtime. Erasure is what allows generic types to interoperate freely with legacy code that does not use generics.

Because of these fundamental differences, **arrays and generics do not mix well**. For example, it is illegal to create an array of generics type, a parameterized type, or a type parameter. None of these array creation expressions are legal: `new List<E>[]`, `new List<String>[]`, `new E[]`. All will result in *generic array creation* errors at compile time.

Why is it illegal to create a generic array? **Because it isn't typesafe**. If is were legal, casts generated by the compiler in an otherwise correct program could fail at runtime with a `ClassCastException`. This would violate the fundamental guarantee provided by the generic type system.

To make this more concrete, consider the following code fragment:

```java
// Why generic array creation is illegal - won't compile!
List<String>[] stringLists = new List<String>[1];       // (1)
List<Integer> intList = Arrays.asList(42);              // (2)
Object[] objects = stringLists;                         // (3)
objects[0] = intList;                                   // (4)
String s = stringLists[0].get(0);                       // (5)
```

Let's pretend that line 1 is legal. Line 2 creates and initializes a `List<Integer>` containing a single element. Line 3 stores the `List<String>` array into an `Object` array variable, which is legal because arrays are covariant. Line 4 stores the `List<Integer>` into the sole element of the `Object` array, which succeeds because generics are implemented by erasure: the runtime type of a `List<Integer>` instance is simply `List`, and the runtime type of a `List<String>[]` instance is `List[]`, so this assignment doesn't generate an `ArrayStoreException`. Now we're in trouble. We've stored a `List<Integer>` instance into an array that is declared to hold only `List<String>` instances. In line 5, we retrieve the sole element from the sole list in this array. The compiler automatically casts the retrieved element to `String`, but it's an `Integer`, so we get a `ClassCastException` at runtime. In order to prevent this from happening, line 1 generates a compile-time error.

Types such as `E`, `List<E>`, and `List<String>` are technically known as *non-reifiable types*. Intuitively speaking, a non-reifiable type is one whose runtime representation contains less information than its compile-time representation. The only parameterized types that are unbounded wildcard types such as `List<?>` and `Map<?, ?>`. It is legal, though infrequently useful, to create arrays of unbounded wildcard types.

#### Summary

In summary, arrays and generics have very different type rules. Arrays are covariant and reified; generics are invariant and erased. As a consequence, arrays provide runtime type safety but not compile-time type safety and vice versa for generics. Generally speaking, arrays and generics don't mix well. If you find yourself mixing them and getting compile-time errors or warnings, your first impulse should be replace the arrays with lists.